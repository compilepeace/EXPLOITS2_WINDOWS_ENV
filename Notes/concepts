
In windows -

->	Address starting with 0x004_____ is the .text segment of the process 
->	Address starting with 0x001_____ is the .stack segment of the process.


#	PDB FILE
=>	This file contains the debugging symbols for a binary. (This may be of .sys format)


#	SEH (Structure Exception Handler) (Bypass Stack Canaries protection)
=>	These are function pointers that exist on stack and get executed when something bad happens. 
	Process knows where the exception handlers are because the TEB (Thread Execution Block) points
	to it, i.e. process meta information referenced by the FS register.

		(windbg) !teb
		TEB at 7ffdf000
			ExceptionList :		0012ffb0
			StackBase 	  : 	00130000	
			.
			.
			.

	The exception handler list will occur bellow than our stack frame, so we can corrupt them via
	buffer overflows.

		(windbg) !exchain
		0012ffb0: mystery!_except_handler4+0 (004022e0)
		0012ffe0: kernel32!_except_handler3+0 (7c839ad8)
		.
		.

		(windbg) dd 0012ffb0				# exploring manually
		0012ffb0	0012ffe0 004022e0 9e391481 00000000
		0012ffc0	0012fff0 7c817077 00b6f6f2 00b6f72e
		0012ffd0	ffffffff



	The ExceptionList is a singly linked list. So whenever a exeception occurs, this linked list at
	address 0012ffb0 is parsed and the respective exeception handler function() is called that 
	handles the exception. The list consists of nodes, where each node consists of 2 DWORDS. 
	First member of the node is a pointer to next node. Second member of the node is actual 
	exception handler function() pointer.	

	Here,
	the first 4 bytes of the exception handler, i.e. '0012ffe0' are the pointer to the next 
	exception handler, the next DWORD (4 bytes) are the actual function pointers.
	The 'ffffffff' at 0x0012ffd0 signifies the end of the linked list.

		structure eh{
			DWORD	*next_exception_handler;
			DWORD 	*actual_function_pointer;
		}
	
	A more reliable way is to overwrite the exception handler list.	


#	SEH MITIGATIONS
=>	When pointing the function pointer to the shellcode on stack, we see that it does not execute.
	This is because of the sanity checks on function pointer addresses by windows that whenever
	the function pointer of exception handler routine points to an address on stack, abort!
	So, we can't directly point to an address on stack (but we can do this indirectly)

	#	SAFE SEH
	=> 	It registers a table of valid f() pointers, which a dll is able to use as exception handler
		and if anything is not in that table, exception handler will not process it. However, there
		are dlls that don't opt into that table. Its a per dll basis mitigation technique. If a dll
		does not have that table, it will allow any address overwritten as its function pointer to
 		be a valid address.

		##	HOW TO LOOK AT WHAT MODULES OPT IN FOR THESE TABLES
		=>
			(windbg) .load narly				# a plugin to identify the modules opting in for 
												# these tables.
			(windbg) !nmod
