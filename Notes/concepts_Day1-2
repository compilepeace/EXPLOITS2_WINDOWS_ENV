
In windows -

->	Address starting with 0x004_____ is the .text segment of the process 
->	Address starting with 0x001_____ is the .stack segment of the process.


~~~~~~~~~~~~~	EXPLOIT MITIGATIONS
=>	There are 2 classes of exploit mitigations.

	1.	Mitigations applied per process/binary basis (eg: /GS protection, SafeSEH)
	2.	Mitigations applied system-wide basis

	* /GS stack protection (telling the compiler to put up stack cannary checking code in binary)
	* DEP (/NoExecute=OptOut or /NoExecute=OptIn )
	* ASLR
	* SafeSEH (has 2 heuristics)
	* Variable reordering


*	/GS STACK PROTETION
=>	In linux, the /GS stack cookie value generally contains NULL bytes \x00, newline \x0a, carriage
 	return \x0d etc. It is the weakest from of mitigation. 
	Drawback: It makes the function extremely slow as it has its own overhead. Visual studio has its
	own rules based on heuristics like if your function contains an ASCII strings more than 4 bytes,
 	it will apply the /GS protection.
	Information leaks are helpful here.

*	DEP 
=>	Edit 'boot.ini' file to change DEP options. Add the following option to boot entry -
	/NoExecute=OptOut 				(used by default in our VMs)
	OptOut means a process has to explicitly register to OS that it wants the DEP turned OFF. (here
	DEP is turned ON by default for every process).	
	OptIn means a process has to explicitly register to OS that it does want DEP turned ON. (here DEP
	is turned ON for everything by default).	
	Two types -
		1. Hardware DEP (NX bit enabled & making sure page tables are checked before EIP goes there)
		2. Software DEP (Its basically the SafeSEH)

*	ASLR (Heap spray is an effective bypass to it)
=>	Executables and their associated DLL's are loaded at random locations in the address space. 
	Information leaks are helpful here.	
	Bypass it by clever methods. Calculate the addresses using return oriented programming and then
	write them into the stack frame before you actually arive at your stack frame.
	How to find address of 'VirtualProtectEx()' in an ASLR environment ?
	If we look at 'Import Address Table' (IAT) for Flash6.ocx, we would see that it is importing 
	functions from kernel32.dll (pretty much every binary does). So when our ROP payload starts 
	running, there will be absoute addresses pointing to kernel32.dll located at a fixed address
	namely Flash's import address table. The very first entry and the import address table for Flash6
	relevant to kernel32 points to GetTimezoneInformation(). This will allow us to know what the 
	address of GetTimezoneInformation() (which is a kernel32 function) is. By knowing this address,
	we can derive the address of 'VirtualProtectEx()' because although the address space of kernel32
	is randomized, the offset to 'VirtualProtectEx()' from 'GetTimezoneInformation()' remains the
	same. 
				GetTimezoneInformation() + offset = VirtualprotectEx()		# Fixed offset
	

*	SafeSEH
=>	Previously we abused the structured exception handller by pointing it to a piece of code that
	was useful to us (a pop-pop-ret sequence). 
	
	SafeSEH has 2 heuristics -	
	1.	We already had the constraint that the exception handler could'nt point to the stack.
	2.	SafeSEH add's further constraints: A SafeSEH enabled module registers a table of valid
	 	exception handlers. Before executing an exception handler routine, the OS first verifies 
		that the exception handler pointer points to an entry in this table. Most of the application
		modules/dlls do not opt in for this constraint, only OS dlls/modules opt into it.


~~~~~~~~~~~~~ 	GAME PLAN
=>
	1.	We'll overwrite the Exception handler and trigger an exception. (This bypasses the /GS 	
		protection because the exception handler will be called before the stack cookie is checked
		at the end of the function epilogue.	
	2.	We'll initially call code in a non-SafeSEH module/dll which bypasses SafeSEH.
	3.	We will then call 'VirtualProtect()' to change the memory protections on the stack to include
		the executable bit bypassing DEP.
	4.	Finally, we jump to our shellcode.	


~~~~~~~~~~~~~	RETURN ORIENTED PROGRAMMING

=>	To keep EIP within our control, we need ESP to point to our data because as soon as the RET 
	instruction gets executed, the DWORD at the top of stack is poped off into EIP which should be
	the data value we control, not random data.
	This is because we want to call 'VirtualProtect()' with the right arguments and the stack 
	controls the arguments. We also want to control where execution flows during a return call and
	the stack controls the result of a return instruction. 


~~~~~~~~~~~~~ 	PDB FILE
=>	This file contains the debugging symbols for a binary. (This may be of .sys format)



~~~~~~~~~~~~~ 	SEH (Structure Exception Handler) (Bypass Stack Canaries protection)

=>	These are function pointers that exist on stack and get executed when something bad happens. 
	Process knows where the exception handlers are because the TEB (Thread Execution Block) points
	to it, i.e. process meta information referenced by the FS register.

		(windbg) !teb
		TEB at 7ffdf000
			ExceptionList :		0012ffb0
			StackBase 	  : 	00130000	
			.
			.
			.

	The exception handler list will occur bellow than our stack frame, so we can corrupt them via
	buffer overflows.

		(windbg) !exchain
		0012ffb0: mystery!_except_handler4+0 (004022e0)
		0012ffe0: kernel32!_except_handler3+0 (7c839ad8)
		.
		.

		(windbg) dd 0012ffb0				# exploring manually
		0012ffb0	0012ffe0 004022e0 9e391481 00000000
		0012ffc0	0012fff0 7c817077 00b6f6f2 00b6f72e
		0012ffd0	ffffffff



	The ExceptionList is a singly linked list. So whenever a exeception occurs, this linked list at
	address 0012ffb0 is parsed and the respective exeception handler function() is called that 
	handles the exception. The list consists of nodes, where each node consists of 2 DWORDS. 
	First member of the node is a pointer to next node. Second member of the node is actual 
	exception handler function() pointer.	

	Here,
	the first 4 bytes of the exception handler, i.e. '0012ffe0' are the pointer to the next 
	exception handler, the next DWORD (4 bytes) are the actual function pointers.
	The 'ffffffff' at 0x0012ffd0 signifies the end of the linked list.

		structure eh{
			DWORD	*next_exception_handler;
			DWORD 	*actual_function_pointer;
		}
	
	A more reliable way is to overwrite the exception handler list.	


#	SEH MITIGATIONS
=>	When pointing the function pointer to the shellcode on stack, we see that it does not execute.
	This is because of the sanity checks on function pointer addresses by windows that whenever
	the function pointer of exception handler routine points to an address on stack, abort!
	So, we can't directly point to an address on stack (but we can do this indirectly)

	#	SafeSEH mitigation
	=> 	It registers a table of valid f() pointers, which a dll is able to use as exception handler
		and if anything is not in that table, exception handler will not process it. However, there
		are dlls that don't opt into that table. Its a per dll basis mitigation technique. If a dll
		does not have that table, it will allow any address overwritten as its function pointer to
 		be a valid address.

		##	HOW TO LOOK AT WHAT MODULES OPT IN FOR THESE TABLES
		=>
			(windbg) .load narly				# a plugin to identify the modules opting in for 
												# these tables.
			(windbg) !nmod


~~~~~~~~~~~~~ 	C++ V-TABLES

=>	Whenever you declare a class with virtual functions, what you are ending up within memory is
	basically a C structre in memory.
	This structure contains all of your variables (like the name[64] buffer), as well as a pointer
	to a function pointer table.	
	The function pointer table stores pointers to all of the methods your C++ class implements.

	The main point is that whenever we declare a C++ class with virtual methods, the pool of memory
	where it exists (the heap, the stack etc..) now contains a pointer to a function pointer table
	which will eventually be used to call the function.

	In the event of an overflow, we can overwrite this pointer value so that our code will be called
	the next time a virtual method is called.


#	USE AFTER FREE VULNERABILITY
=>	Use after free actually exloits the 'dangling pointers' (pointers to free memory chunks)	

	eg:

	Person p = new Person;		// creating an object 'p' of class 'Person'	
	
	           |---------|
	p -------> | V Table |
	           |---------|
	
	free(p);					// or delete p; heap allocator marks memory at 'p' to be available



#	HEAP SPRAY
=>	Here we spray the whole heap segment with our shellcode. The next time it goes to C++ class to 
	use heap memory, we trick the Internet explorer to execute our shellcode.

	The javascript string allocator and the Internet Explorer process share the same heap. This is
	what makes it exploitable. It is easy at the client side but you are the person to perform at
	the server side where it is more challenging.


~~~~~~~~~~~~~ 	HEAP ALLOCATORS VS VTABLES OVERWRITE
=>	In windows xp and beyond, overwriting heap metadata and control block is quite challenging and
	complicated. So whenever we find heap overflows in windows XP and beyond, instead of corrupting
	the heap metadata and control block, we will overwrite/corrupt the application data to perform
	arbitrary code execution.


~~~~~~~~~~~~~	RETURN ORIENTED PROGRAMMING (ROP)

=>	 We will need to control the EIP and ESP to gain control of execution and do ROP.

	(windbg)> !lmi module_name					# To search a module
	(windbg)> s module_name L194000 aa bb cc	# To search for 'aa bb cc' opcode in 'module_name'


~~~~~~~~~~~~~	BYPASSING DEP WITH ROP's VirtualProtectEx()


Syntax -

	BOOL VirtualProtectEx(
	  HANDLE hProcess,
	  LPVOID lpAddress,
	  SIZE_T dwSize,
	  DWORD  flNewProtect,
	  PDWORD lpflOldProtect
	);


#	hProcess 
=>	A handle to the process whose memory protection is to be changed.

#	lpAddress
=>	A pointer to the base address of the region of pages whose access protection attributes are to 
	be changed.

#	dwSize
=>	The size (in bytes) of the regions whose access protection attributes are changed.

#	flNewProtect
=>	The memory protection option.
		0x10		PAGE_EXECUTE
		0X20		PAGE_EXECUTE_READ
		0X40		PAGE_EXECUTE_READWRITE
		0X80		PAGE_EXECUTE_WRITECOPY
		0X01		PAGE_NOACCESS
		0X02 		PAGE_READONLY
		0X04		PAGE_READWRITE
		0X08		PAGE_WRITE_COPY
		0X40000000	PAGE_TARGETS_INVALID
		

#	lpflOldProtect
=>	A pointer to variable that recieves the previous access protection of the first page in the 
	specified region of pages.


~~~~~~~~~~~~~   BYPASSING ASLR WITH ROP's AND USING VirtualProtectEx()


Syntax -

    BOOL VirtualProtectEx(
      HANDLE hProcess,
      LPVOID lpAddress,
      SIZE_T dwSize,
      DWORD  flNewProtect,
      PDWORD lpflOldProtect
    );

Stack frame should be like this - 


[unknown VirtualProtect Address] : AAAAAAAA
[unknown return address] : BBBBBBBB
ffffffff
[unknown lpAddress] : CCCCCCCC
0xa000
0x40
[unknown old protect address] : DDDDDDDD <- Address of Data region in Flash (any writable memory area) 
