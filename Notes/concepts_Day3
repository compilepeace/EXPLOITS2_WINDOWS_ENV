
~~~~~~~~~	COREY'S TIPS ON FINDING BUGS

1.	Mutational fuzzing works in the field.


2.	Reverse Engineering
=>	He'll want to first go to the import section of the binary to look for any vulnerable function
	imported. (sprintfA, strcpy, scanf or any unsafe library functions)
=>	After finding any vulnerable f(), he'll do a cross-reference on it and identify those blocks of
	code. Identify these blocks by adding colors and adding bookmarks.
=>	Then he's gonna set a breakpoint on where the 'attacker-controlled-data' enters into a process. 
=>	He'll try instrumenting the execution of program trying to reach the execution to those 	
	vulnerable red colored blocks.
=>	The question if if he can reach those block of code with 'attacker-controlled-data'... For this
	read about 'IDAPython plugin' (for path-finding functionality).

~>	Or looking at IAT (Import Address Table) for memory allocating functions (like malloc, alloc 
	etc..) and cross-reference those to see if there are any arithemetic or multiplication happening.
~>	So, the chances are of finding an integer overflow. Where the program is trying to do arithemetic
	or multiplicative operation on 'attacker-control-data' allowing the attacker to make those
	integers arbitrarily big.


3.	When to use RE and when to use FUZZING ??
=>	When finding bugs on a remote application, you would like to start with RE after all the nasty
	networking protocols.
=>	When finding bugs in any client-side application, fuzzing is usually a better option.


4.	Try to do BOTH simultaneously. Let the CPU cycles fuzz the appication while put your brain into
	Reverse Engineering the application. That allows you to make your fuzzer better.



~~~~~~~~~	IS THE BUG IN CRASH EXPLOITABLE

=>	Execute the program with crash file in windbg and let it crash

>	.load msec
> 	!exploitable


#	SOME CRASH REPORTS

=>	mov	eax, [ecx]				; ecx = 0x00000000 (NULL pointer dereference mostly unexploitable)

=>	rep	movsd					; sysnonymous to memcpy(), uses ESI and EDI 
	if esi or edi are filled with (ee fe ee fe ee fe ee fe ee fe ee fe ...), it probably means that
	the value at the source or destination are not controlled by us. These are put up by microsoft
	to uninitialized variables.


#	WHAT TO LOOK FOR IN CRASH REPORTS 

1.	okay, 'reps instruction' is a memcpy()
2.	Where is attacker controled data being written to ?
3.	Is it written to the stack or the heap? (stack overflows are easier to exploit than heap ones)
4.	You might control the source data.
5.	How much data is being written there ?
6.	Are the exception handlers corrupted at the crash ?
7.	How do I determine if I control that data or not ?


~~~~~~~~~	REPRODUCING THE CRASH AND CREATING EXPLOIT

=>	First, load the crash file and let the program crash in debugger, then trace through the stack 
	calls by 'kv' command (to see which function caused the crash).
=>	Break right before that crash. (Do this by looking at the output of kv command and unassemble
	backwards by 'ub' command on the return address of the crash()).


~~~~~~~~~	EXPLOIT DEVELOPMENT

ANSWER THESE QUESTIONS TO YOURSELF

1.	Where is the memcpy called that corrupts the stack ?
2.	What are the arguments to memcpy ?
3.	What is the address of buffer I am overflowing ?
4. 	What is the delta between the overflowed buffer and the exception handler ?
5.	Where is the source data to the memcpy located in my payload file (find the offset) ?
6. 	What offset in my file represents what will overwrite the exception handler ?


How to go for question 5.
=>	Dereference the source address and find that data in the payload file and NOTE down its OFFSET in
	payload file.

~~~~~~~~~	FUZZING

=>	Classified into 2 approaches - 

1.	Mutational 
2.	Generational (eg: spike, sulley etc.)

=>	Mutational fuzzing is dones by first downloading many samples of test files and altering each
	byte of the file as using it as a test case. At last analysing crash reports.
	Generational fuzzing involves identifying and analysing the test file structures or making an 
	XML file for a general structure for the type of file the software application accepts.

=>	The main part of fuzzing is 'code-coverage'
=>	Using PyDbg is a python debugger usedful while exloit-development on windows
